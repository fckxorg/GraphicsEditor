#include "window.hpp"

#include <bits/stdint-uintn.h>

/*--------------- WINDOW ---------------------*/

Window::Window() = default;
bool Window::is_opened() const { return opened; }

void Window::set_event_mask(uint32_t mask) { event_mask = mask; }

void Window::add_child_window(std::unique_ptr<Window>& child) {
    subwindows.push_back(std::move(child));
}

Window::~Window() = default;

void Window::handle_event(Event& event) {
    for (auto& subwindow : subwindows) {
        subwindow->handle_event(event);
    }
}

/*----------- RENDER WINDOW ----------------*/

RenderWindow::RenderWindow() = default;
RenderWindow::~RenderWindow() = default;
RenderWindow::RenderWindow(Size size, Position pos) : size(size), pos(pos) {}

void RenderWindow::open() { opened = true; }
void RenderWindow::close() { opened = false; }

void RenderWindow::refresh() {}

void RenderWindow::set_pos(Position pos) { this->pos = pos; }
Position RenderWindow::get_position() const { return pos; }

void RenderWindow::set_rotation(const float rotation) {
    this->rotation = rotation;
}
float RenderWindow::get_rotation() const { return rotation; }

/*---------- RECT WINDOW -------------------*/

RectWindow::RectWindow() = default;
RectWindow::~RectWindow() = default;
RectWindow::RectWindow(Size size, Position pos, Color color)
    : RenderWindow(size, pos), color(color) {}

void RectWindow::render() {
    if (!this->opened) {
        return;
    }

    Renderer::draw_rectangle(size, pos, color);

    for (auto& subwindow : subwindows) {
        subwindow->render();
    }
}

void RectWindow::set_color(Color color) { this->color = color; }

Color RectWindow::get_color() { return color; }

/* --------- RECT BUTTON -------------------*/
RectButton::RectButton() = default;
RectButton::~RectButton() = default;

RectButton::RectButton(Size size, Position pos, Color color)
    : RectWindow(size, pos, color), default_color(color) {}

void RectButton::render() {
    if (!this->opened) {
        return;
    }

    RectWindow::render();

    for (auto& subwindow : subwindows) {
        subwindow->render();
    }
}

bool RectButton::check_boundaries(Position click_pos) {
    if (click_pos.x < pos.x || click_pos.x > pos.x + size.width) return false;
    if (click_pos.y < pos.y || click_pos.y > pos.y + size.height) return false;

    return true;
}

void RectButton::onMousePress(Event& event) {
    Position click_position = event.mouse_button_event.pos;
    if (!check_boundaries(click_position)) return;

    Color curr_color = RectWindow::get_color();

    uint8_t color_r_pressed = std::min(curr_color.r - 50, 0);
    uint8_t color_g_pressed = std::min(curr_color.g - 50, 0);
    uint8_t color_b_pressed = std::min(curr_color.b - 50, 0);

    Color pressed_color =
        Color(color_r_pressed, color_g_pressed, color_b_pressed);
    this->color = pressed_color;
}

void RectButton::onMouseRelease(Event& event) { this->color = default_color; }

void RectButton::handle_event(Event& event) {
    switch (event.type) {
        case MOUSE_BUTTON_PRESSED:
            RectButton::onMousePress(event);
            break;
        case MOUSE_BUTTON_RELEASED:
            RectButton::onMouseRelease(event);
            break;
    }

    for (auto& subwindow : subwindows) {
        subwindow->handle_event(event);
    }
}

/*--------------- TEXT WINDOW-----------------------------*/

TextWindow::TextWindow() = default;
TextWindow::TextWindow(Text text, Position pos, Color bgcolor)
    : text(text), bgcolor(bgcolor) {
    set_pos(pos);
}

Text TextWindow::get_text() const { return text; }

void TextWindow::set_text(Text text) { this->text = text; }

Color TextWindow::get_bgcolor() const { return bgcolor; }

void TextWindow::set_bgcolor(Color bgcolor) { this->bgcolor = bgcolor; }

void TextWindow::render() {
    Renderer::draw_text(text, pos, bgcolor);

    for (auto& subwindow : subwindows) {
        subwindow->render();
    }
}

/*---------------- Slieder ------------------------------*/
Slider::Slider() = default;
Slider::~Slider() = default;
Slider::Slider(Size size, Position pos, Color color, uint16_t lower_bound,
               uint16_t upper_bound, bool horizontal)
    : RectWindow(size, pos, color),
      default_color(color),
      pressed(false),
      lower_bound(lower_bound),
      upper_bound(upper_bound),
      horizontal(horizontal) {}

void Slider::handle_event(Event& event) {
    switch (event.type) {
        case MOUSE_BUTTON_PRESSED:
            onMousePress(event);
            break;
        case MOUSE_BUTTON_RELEASED:
            onMouseRelease(event);
            break;
        case MOUSE_MOVED:
            onMouseMove(event);
            break;
    }
}

// TODO move this method to RectWindow
bool Slider::check_boundaries(Position click_pos) {
    if (click_pos.x < pos.x || click_pos.x > pos.x + size.width) return false;
    if (click_pos.y < pos.y || click_pos.y > pos.y + size.height) return false;

    return true;
}

void Slider::onMousePress(Event& event) {
    Position click_position = event.mouse_button_event.pos;
    if (!check_boundaries(click_position)) return;

    Color curr_color = RectWindow::get_color();

    uint8_t color_r_pressed = std::min(curr_color.r - 50, 0);
    uint8_t color_g_pressed = std::min(curr_color.g - 50, 0);
    uint8_t color_b_pressed = std::min(curr_color.b - 50, 0);

    Color pressed_color =
        Color(color_r_pressed, color_g_pressed, color_b_pressed);
    this->color = pressed_color;
    pressed = true;
}

void Slider::onMouseMove(Event& event) {
    if (!pressed) return;
    Position mouse_position = event.mouse_move_event.pos;

    if (check_boundaries(mouse_position)) return;

    Position new_pos = {};

    if(horizontal) {
        uint16_t adjusted_upper_bound = std::max(upper_bound - size.width, 0);
        new_pos.x = std::min(mouse_position.x, adjusted_upper_bound);
        new_pos.x = std::max(mouse_position.x, lower_bound);
        
        new_pos.y = pos.y;
    }
    else {
         uint16_t adjusted_upper_bound = std::max(upper_bound - size.height, 0);
        new_pos.y = std::min(mouse_position.y, adjusted_upper_bound);
        new_pos.y = std::max(mouse_position.y, lower_bound);
        
        new_pos.x = pos.x;

    }

    this->pos = new_pos;
}

void Slider::onMouseRelease(Event& event) {
    this->color = default_color;
    pressed = false;
}
